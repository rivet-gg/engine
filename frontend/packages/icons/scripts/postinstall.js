const fs = require("node:fs");
const dedent = require("dedent");
const { spawnSync } = require("node:child_process");
const { join, resolve } = require("node:path");
const manifest = require("./../manifest.json");
const esbuild = require("esbuild");

const hasFaToken = !!process.env.FONTAWESOME_PACKAGE_TOKEN;

const sourceDir = join(__dirname, "..", "src");
const sourceNodeModules = join(sourceDir, "node_modules");

if (!fs.existsSync(sourceDir)) {
	fs.mkdirSync(sourceDir, { recursive: true });
}

if (process.env.FONTAWESOME_PACKAGE_TOKEN) {
	// Configure auth for Font Awesome private registry via .npmrc for pnpm
	fs.writeFileSync(
		join(sourceDir, ".npmrc"),
		dedent`
		@fortawesome:registry=https://npm.fontawesome.com/
		@awesome.me:registry=https://npm.fontawesome.com/
		//npm.fontawesome.com/:_authToken=\${FONTAWESOME_PACKAGE_TOKEN}
		//npm.fontawesome.com/:always-auth=true
		`,
	);

	fs.writeFileSync(
		join(sourceDir, "./package.json"),
		JSON.stringify(
			{
				name: "@rivet-gg/internal-icons",
				private: true,
				sideEffects: false,
				dependencies: {
					"@awesome.me/kit-63db24046b": "^1.0.15",
					"@fortawesome/pro-regular-svg-icons": "6.6.0",
					"@fortawesome/pro-solid-svg-icons": "6.6.0",
				},
			},
			null,
			2,
		),
	);

	// Install dependencies locally without engaging the workspace to avoid recursion
	spawnSync("npm", ["install", "--no-package-lock", "--silent"], {
		stdio: "inherit",
		cwd: sourceDir,
		env: { ...process.env, CI: 0 },
	});
}

const banner = dedent`
  // This file is generated by scripts/postinstall.js
  // Do not modify this file directly
  // ${hasFaToken ? "This file includes pro icons" : "This file does not include pro icons, all pro icons are replaced with square icon. To use pro icons, please add FONTAWESOME_PACKAGE_TOKEN to your environment and rebuild this package."} \n


`;

let indexJsSource = dedent`
  ${banner}
  import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
  import { createElement } from "react";
  export function Icon(props) { return createElement(FontAwesomeIcon, props)}
`;

for (const [pkg, { icons }] of Object.entries(manifest)) {
	const isCustom = pkg.startsWith("@awesome.me/kit-");
	const isPro = pkg.startsWith("@fortawesome/pro-");

	if (isCustom) {
		if (hasFaToken) {
			const iconNames = icons.map(({ icon }) => icon);
			const exp = iconNames
				.join(", ");
			indexJsSource += `export { ${exp} } from "${pkg}";\n`;
		} else {
			const iconNames = icons.map(({ icon }) => icon);
			const exp = iconNames
				.map((icon) => `definition as ${icon}`)
				.join(", ");
			indexJsSource += `export { ${exp} } from "@fortawesome/free-solid-svg-icons/faSquare";\n`;
		}
	} else {
		for (const { icon, aliases } of icons) {
			if (!indexJsSource.includes(`export { definition as ${icon} }`)) {
				if (hasFaToken || !isPro) {
					if (hasFaToken && isPro) {
						const candidate = join(
							sourceNodeModules,
							pkg,
							`${icon}.js`,
						);
						if (fs.existsSync(candidate)) {
							indexJsSource += `export { definition as ${icon} } from "${pkg}/${icon}";\n`;
						} else {
							indexJsSource += `export { definition as ${icon} } from "@fortawesome/free-solid-svg-icons/faSquare";\n`;
						}
					} else {
						indexJsSource += `export { definition as ${icon} } from "${pkg}/${icon}";\n`;
					}
				} else {
					indexJsSource += `export { definition as ${icon} } from "@fortawesome/free-solid-svg-icons/faSquare";\n`;
				}
			}
			for (const alias of aliases) {
				if (
					alias === icon ||
					indexJsSource.includes(`export { definition as ${icon} }`)
				) {
					continue;
				}
				if (hasFaToken && isPro) {
					const candidate = join(
						sourceNodeModules,
						pkg,
						`${icon}.js`,
					);
					if (fs.existsSync(candidate)) {
						indexJsSource += `export { definition as ${alias} } from "${pkg}/${icon}";\n`;
					} else {
						indexJsSource += `export { definition as ${alias} } from "@fortawesome/free-solid-svg-icons/faSquare";\n`;
					}
				} else {
					indexJsSource += `export { definition as ${alias} } from "${pkg}/${icon}";\n`;
				}
			}
		}
	}
}
fs.writeFileSync(join(sourceDir, "index.gen.js"), `${indexJsSource}`);

const indexTsSource = dedent`
  ${banner}
  import { FontAwesomeIcon, FontAwesomeIconProps } from "@fortawesome/react-fontawesome";
  import { ComponentProps, createElement } from "react";
  export function Icon(props: Omit<ComponentProps<typeof FontAwesomeIcon>, 'icon'> & {icon: IconProp}) { return createElement(FontAwesomeIcon, props as FontAwesomeIconProps)}
  export type IconProp = string | { prefix: string; iconName: string } | [string, string];
  ${indexJsSource.split("\n").slice(8).join("\n")}
`;
fs.writeFileSync(join(sourceDir, "index.gen.ts"), `${indexTsSource}`);

async function build() {
	console.log(
		`Generating icon exports. Pro icons will ${hasFaToken ? "" : "not "}be included.`,
	);
	const externals = [
		"react",
		"react-dom",
		"@fortawesome/react-fontawesome",
		"@fortawesome/fontawesome-svg-core",
		"@fortawesome/free-solid-svg-icons",
		"@fortawesome/free-brands-svg-icons",
		// Only treat Pro packages as external when we DON'T have a token.
		// When token is present, we bundle Pro icons into dist so consumers
		// don't need to resolve these at runtime from their node_modules.
		// This avoids Module Not Found errors during Next.js builds.
		...(hasFaToken
			? []
			: [
					"@fortawesome/pro-solid-svg-icons",
					"@fortawesome/pro-regular-svg-icons",
				]),
	];

	await esbuild.build({
		entryPoints: [resolve(sourceDir, "index.gen.js")],
		outfile: resolve(__dirname, "..", "dist", "index.js"),
		external: externals,
		bundle: true,
		platform: "browser",
		format: "esm",
		treeShaking: true,
	});
}

build();
